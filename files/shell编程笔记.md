* nohup

> nohup命令是一个 POSIX 命令，用于忽略 SIGHUP ("signal hang up" 译：挂断信号) 。 SIGHUP信号是终端注销时所发送至程序的一个信号。
> 
> nohup命令，在默认情况下（非重定向时），会输出一个名叫 nohup.out 的文件到终端上。
> 
> --《维基百科》

```shell
# 下例中，nohup用于忽略SIGHUP信号，&使命令于后台执行，因此终端退出后命令仍旧执行。
nohup 命令名 &

nohup /mnt/Nand3/H2000G >/dev/null 2>&1 &
# 对 于& 1 更准确的说应该是文件描述符 1,而1 一般代表的就是STDOUT_FILENO,
# 实际上这个操作就是一个dup2(2)调用.他标准输出到all_result ,然后复制标准
# 输出到文件描述符2(STDERR_FILENO),其后果就是文件描述符1和2指向同一个文件
# 表项,也可以说错误的输出被合并了.其中0 表示键盘输入 1表示屏幕输出 2表示错误
# 输出.把标准出错重定向到标准输出,然后扔到/DEV/NULL下面去。通俗的说，就是把
# 所有标准输出和标准出错都扔到垃圾桶里面。

command >out.file 2>&1 &
# command >out.file是将command的输出重定向到out.file文件，即输出内容不打印到
# 屏幕上，而是输出到out.file文件中。 2>&1 是将标准出错重定向到标准输出，这里的
# 标准输出已经重定向到了out.file文件，即将标准出错也输出到out.file文件中。最后一
# 个& ， 是让该命令在后台执行。
# 试想2>1代表什么，2与>结合代表错误重定向，而1则代表错误重定向到一个文件1，而
# 不代表标准输出；换成2>&1，&与1结合就代表标准输出了，就变成错误重定向到标准输出

```

